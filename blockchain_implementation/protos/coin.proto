syntax = "proto3";
package protos;

// Maybe look at adding the scripting functionality to 
// unlock UTXOs
// Each transaction references as input a UTXO from the existing
// set of UTXOs
// But how does it start? Every client knows about the genesis block
// which when mined introduces new coin from thin air (no inputUTXO)
message Transaction {
    // UTXO is a transaction hash and the receiver in that transaction
    // is like the source.
    // Unless it is money creation which we can signify as 
    // zeroed bytes for example
    bytes inputUTXO = 1;
    // To make life easier for implementing coinbase transactions
    // Lets also include the source pubKey, in theory you don't 
    // even need this because the inputUTXO's receiverPubKey
    // is really the source
    bytes senderPubKey = 2; 
    // Destination of the UTXO
    bytes receiverPubKey = 3;
    // Ensures the private key associated with the public key in the inputUTXO was actually used to sign this 
    // Note the way it really works is there is a locking and unlocking
    // script, but more or less the locking script just contains the pub
    // key of the receiver and to unlock it you provide an unlocking
    // script with a signature signed by the private key associated
    // with that public key
    bytes signature = 4;
    uint64 value = 5;
    // Height is guaranteed to be unique per miner, in the real bitcoin network this
    // goes in the coinbase script arbirary data section but in general this 
    // resolves the issue of identical coinbase transactions for the same miner
    // currently only used for coinbase transactions
    uint64 height = 6;
}

message BlockHeader {
    bytes prevBlockHash = 1;
    // Used to check whether a transaction is in the block 
    // in logarithmic time, AFAIK this is only used in SPV clients
    // So they do not need to download the full blocks
    bytes merkleRoot = 2;
    uint64 timeStamp = 3; // seconds from epoch
    uint32 difficultyTarget = 4;
    uint32 nonce = 5; 
    uint64 height = 6; // essentially the block number 
}

// Hash of the block is made by hashing the blockheader twice
message Block {
    BlockHeader header = 1;
    repeated Transaction transactions = 2;
}

message Empty {
}

message Hello {
}

message Ack {
}

service Peering {
    // Could add version exchange during peer connection
    rpc Connect(Hello) returns (Ack) {}
}

service Transactions {
    rpc ReceiveTransaction(Transaction) returns (Empty) {} 
    rpc SendTransaction(Transaction) returns (Empty) {}
}

service Blocks {
    rpc SendBlock(Block) returns (Empty) {} 
    rpc ReceiveBlock(Block) returns (Empty) {}
}

service State {
    // Could be a huge number of blocks and transactions
    // lets use a stream
    rpc GetTransactions(Empty) returns (stream Transaction) {}
    rpc GetBlocks(Empty) returns (stream Block) {}
}

message Account {
    string name = 1;
} 
message AccountCreated {
    string address = 1;
}

message Balance {
    uint64 balance = 1;
}

service Wallet {
    rpc NewAccount(Account) returns (AccountCreated) {}
    rpc GetBalance(Empty) returns (Balance) {}
    rpc GetAddress(Empty) returns (AccountCreated) {}
}

service Miner {
    rpc StartMining(Empty) returns (Empty) {}
    rpc StopMining(Empty) returns (Empty) {}
}
